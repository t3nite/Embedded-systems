#include <zephyr/kernel.h>
#include <zephyr/sys/printk.h>
#include <zephyr/device.h>
#include <zephyr/drivers/gpio.h>

// Led pin configurations
static const struct gpio_dt_spec red = GPIO_DT_SPEC_GET(DT_ALIAS(led0), gpios);
static const struct gpio_dt_spec green = GPIO_DT_SPEC_GET(DT_ALIAS(led1), gpios);
static const struct gpio_dt_spec blue = GPIO_DT_SPEC_GET(DT_ALIAS(led2), gpios);

// Button pin (katso device tree alias: button0)
static const struct gpio_dt_spec button = GPIO_DT_SPEC_GET(DT_ALIAS(sw0), gpios); // Nappi VOL-

// Red led thread initialization
#define STACKSIZE 500
#define PRIORITY 5

// FSM states
typedef enum {
    STATE_RED,
    STATE_YELLOW,
    STATE_GREEN,
    STATE_PAUSE
} state_t;

static state_t state = STATE_RED;
static state_t prev_state = STATE_RED; // tallennetaan viimeinen aktiivinen tila

void fsm_task(void *, void *, void*);
void button_pressed_callback(const struct device *dev, struct gpio_callback *cb, uint32_t pins);

K_THREAD_DEFINE(fsm_thread, STACKSIZE, fsm_task, NULL, NULL, NULL, PRIORITY, 0, 0);

// GPIO callback struct
static struct gpio_callback button_cb_data;

// Initialize leds + button
int init_hardware() {
    int ret;

    // LEDit
    ret = gpio_pin_configure_dt(&red, GPIO_OUTPUT_ACTIVE);
    if (ret < 0) return ret;
    ret = gpio_pin_configure_dt(&green, GPIO_OUTPUT_ACTIVE);
    if (ret < 0) return ret;
    ret = gpio_pin_configure_dt(&blue, GPIO_OUTPUT_ACTIVE);
    if (ret < 0) return ret;

    gpio_pin_set_dt(&red, 0);
    gpio_pin_set_dt(&green, 0);
    gpio_pin_set_dt(&blue, 0);

    // Button
    if (!device_is_ready(button.port)) {
        printk("Error: button device %s is not ready\n", button.port->name);
        return -1;
    }

    ret = gpio_pin_configure_dt(&button, GPIO_INPUT);
    if (ret < 0) return ret;

    ret = gpio_pin_interrupt_configure_dt(&button, GPIO_INT_EDGE_TO_ACTIVE);
    if (ret < 0) return ret;

    gpio_init_callback(&button_cb_data, button_pressed_callback, BIT(button.pin));
    gpio_add_callback(button.port, &button_cb_data);

    printk("Hardware initialized ok\n");
    return 0;
}

// Main program
int main(void)
{
	//init_led();
    init_hardware();
    return 0;
}

// FSM thread
void fsm_task(void *, void *, void*) {
    printk("FSM thread started\n");

    while (1) {
        switch (state) {
            case STATE_RED:
                gpio_pin_set_dt(&red, 1);
                gpio_pin_set_dt(&green, 0);
                printk("RED\n");
                k_sleep(K_SECONDS(1));
                if (state == STATE_RED) {   // vaihda tilaa vain jos ei kesken kaiken menty pauseen
        state = STATE_YELLOW;
    }
                break;

            case STATE_YELLOW:
                gpio_pin_set_dt(&red, 1);
                gpio_pin_set_dt(&green, 1);  // punainen + vihreä = keltainen
                printk("YELLOW\n");
                k_sleep(K_SECONDS(1));
                if (state == STATE_YELLOW) {   // vaihda tilaa vain jos ei kesken kaiken menty pauseen
        state = STATE_GREEN;
    }
                break;

            case STATE_GREEN:
                gpio_pin_set_dt(&red, 0);
                gpio_pin_set_dt(&green, 1);
                printk("GREEN\n");
                k_sleep(K_SECONDS(1));
                if (state == STATE_GREEN) {   // vaihda tilaa vain jos ei kesken kaiken menty pauseen
        state = STATE_RED;
    }
                break;

            case STATE_PAUSE:
                // kaikki ledit pois päältä
                gpio_pin_set_dt(&red, 0);
                gpio_pin_set_dt(&green, 0);
                gpio_pin_set_dt(&blue, 0);
                printk("PAUSE\n");
                k_sleep(K_MSEC(100)); // pieni viive ettei CPU kuormitu
                break;
        }
    }
}

// Button interrupt handler
void button_pressed_callback(const struct device *dev, struct gpio_callback *cb, uint32_t pins) {
    printk("button pressed\n");

    if (state == STATE_PAUSE) {
        // jatketaan siitä tilasta missä oltiin ennen pausea
        state = prev_state;
    } else {
        // mennään pause-tilaan, mutta talletetaan edellinen tila
        prev_state = state;
        state = STATE_PAUSE;
    }
}
