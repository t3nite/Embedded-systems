#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <stdio.h>
#include "TimeParser.h"

// time format: HHMMSS (6 characters)
int time_parse(char *time) {

    // how many seconds, default returns error
    int seconds = TIME_LEN_ERROR;

    if (time == NULL) {
        return TIME_ARRAY_ERROR;
    }

     if (strlen(time) == 0) {
        return TIME_ARRAY_ERROR;      // tyhjä merkkijono
    }

    if (strlen(time) != 6) {
        return TIME_LEN_ERROR;
    }

    // Varmistetaan, että kaikki merkit ovat numeroita
    for (int i = 0; i < 6; ++i) {
        if (!isdigit((unsigned char)time[i])) {
            return TIME_VALUE_ERROR;
        }
    }

    int values[3];
    values[2] = atoi(time+4); // seconds
    time[4] = 0;
    values[1] = atoi(time+2); // minutes
    time[2] = 0;
    values[0] = atoi(time);   // hours

    // boundary checks
    if (values[0] < 0 || values[0] > 23) return TIME_VALUE_ERROR;
    if (values[1] < 0 || values[1] > 59) return TIME_VALUE_ERROR;
    if (values[2] < 0 || values[2] > 59) return TIME_VALUE_ERROR;

    
    if (values[1] == 0 && values[2] == 0) return TIME_ZERO_ERROR;

    // only minutes and seconds count
    seconds = values[1] * 60 + values[2];

    return seconds;
}

int traffic_parse(const char *input, traffic_sequence_t *seq) {
    if (!input || !seq) return TRAFFIC_FORMAT_ERROR;

    seq->length = 0;
    seq->repeat = 1;

    const char *p = input;
    while (*p) {
        char color;
        int time, nread;
        if (sscanf(p, " %c , %d %n", &color, &time, &nread) >= 2) {

            if (color == 'T') {
                seq->repeat = time;
                if (seq->repeat <= 0) return TRAFFIC_REPEAT_ERROR;
            } else if (color == 'R' || color == 'Y' || color == 'G') {
                if (seq->length >= 40) return TRAFFIC_FORMAT_ERROR;

                // tarkistus: yksittäinen aika ei yli 10s (10000ms)
                if (time > 10000) return TRAFFIC_FORMAT_ERROR;

                seq->colors[seq->length] = color;
                seq->times[seq->length] = time;
                seq->length++;
            } else {
                return TRAFFIC_CHAR_ERROR; // väärä merkki
            }
            p += nread;
        } else {
            return TRAFFIC_FORMAT_ERROR;
        }
        while (*p == ',' || *p == ' ' || *p == '\r' || *p == '\n') p++;
    }
    return TRAFFIC_OK;
}
