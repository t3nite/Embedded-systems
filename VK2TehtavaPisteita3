// Perustelut: Lisätty tehtävässä mainitut toiminnot napeille 2-5

#include <zephyr/kernel.h>
#include <zephyr/sys/printk.h>
#include <zephyr/device.h>
#include <zephyr/drivers/gpio.h>

// LED pin configurations
static const struct gpio_dt_spec red = GPIO_DT_SPEC_GET(DT_ALIAS(led0), gpios);
static const struct gpio_dt_spec green = GPIO_DT_SPEC_GET(DT_ALIAS(led1), gpios);
static const struct gpio_dt_spec blue = GPIO_DT_SPEC_GET(DT_ALIAS(led2), gpios);

// Button pin (device tree alias)
static const struct gpio_dt_spec button1 = GPIO_DT_SPEC_GET(DT_ALIAS(sw0), gpios); // Nappi 1 - Pause
static const struct gpio_dt_spec button2 = GPIO_DT_SPEC_GET(DT_ALIAS(sw1), gpios); // Nappi 2 - RED
static const struct gpio_dt_spec button3 = GPIO_DT_SPEC_GET(DT_ALIAS(sw2), gpios); // Nappi 3 - YELLOW
static const struct gpio_dt_spec button4 = GPIO_DT_SPEC_GET(DT_ALIAS(sw3), gpios); // Nappi 4 - GREEN
static const struct gpio_dt_spec button5 = GPIO_DT_SPEC_GET(DT_ALIAS(sw4), gpios); // Nappi 5 - Vilkkuva keltainen

// Manuaalisten LEDien tilat
static bool red_manual = false;
static bool yellow_manual = false;
static bool green_manual = false;

// Viestijono
#define MSG_QUEUE_SIZE 10
struct k_msgq button_msgq;
struct button_msg {
    int button_id;
};
K_MSGQ_DEFINE(button_msgq, sizeof(struct button_msg), MSG_QUEUE_SIZE, 4);

// Thread parameters
#define STACKSIZE 500
#define PRIORITY 5

typedef enum {
STATE_RED,
STATE_YELLOW,
STATE_GREEN,
STATE_PAUSE,
STATE_BLINK_YELLOW
} state_t;

static state_t state = STATE_RED;
static state_t prev_state = STATE_RED;

// Thread & callbacks
void fsm_task(void *, void *, void *);
K_THREAD_DEFINE(fsm_thread, STACKSIZE, fsm_task, NULL, NULL, NULL, PRIORITY, 0, 0);

static struct gpio_callback button1_cb_data;
static struct gpio_callback button2_cb_data;
static struct gpio_callback button3_cb_data;
static struct gpio_callback button4_cb_data;
static struct gpio_callback button5_cb_data;

// Forward declarations
void button_pressed_callback(const struct device *dev, struct gpio_callback *cb, uint32_t pins);

int init_hardware() {
 int ret;
 const struct gpio_dt_spec leds[] = {red, green, blue};
 const struct gpio_dt_spec buttons[] = {button1, button2, button3, button4, button5};

// LEDit
 for (int i = 0; i < 3; i++) {
 ret = gpio_pin_configure_dt(&leds[i], GPIO_OUTPUT_ACTIVE);
 if (ret < 0) return ret;
 gpio_pin_set_dt(&leds[i], 0);
 }

// Nappien määritys
 for (int i = 0; i < 5; i++) {
 if (!device_is_ready(buttons[i].port)) {
 printk("Error: button device %s not ready\n", buttons[i].port->name);
 return -1;
 }
 ret = gpio_pin_configure_dt(&buttons[i], GPIO_INPUT);
 if (ret < 0) return ret;
 ret = gpio_pin_interrupt_configure_dt(&buttons[i], GPIO_INT_EDGE_TO_ACTIVE);
 if (ret < 0) return ret;
 }

// Callbackit
 gpio_init_callback(&button1_cb_data, button_pressed_callback, BIT(button1.pin));
 gpio_add_callback(button1.port, &button1_cb_data);

 gpio_init_callback(&button2_cb_data, button_pressed_callback, BIT(button2.pin));
 gpio_add_callback(button2.port, &button2_cb_data);

 gpio_init_callback(&button3_cb_data, button_pressed_callback, BIT(button3.pin));
 gpio_add_callback(button3.port, &button3_cb_data);

 gpio_init_callback(&button4_cb_data, button_pressed_callback, BIT(button4.pin));
 gpio_add_callback(button4.port, &button4_cb_data);

 gpio_init_callback(&button5_cb_data, button_pressed_callback, BIT(button5.pin));
 gpio_add_callback(button5.port, &button5_cb_data);

 printk("Hardware initialized ok\n");
return 0;
}

int main(void) {
 init_hardware();
 return 0;
}

void fsm_task(void *, void *, void*) {
printk("FSM thread started\n");
 struct button_msg msg;

 while (1) {
// Tarkista saapuvat viestit ennen tilan käsittelyä
if (k_msgq_get(&button_msgq, &msg, K_NO_WAIT) == 0) {
printk("Processing button %d message\n", msg.button_id);
switch (msg.button_id) {
case 1: // PAUSE
if (state == STATE_PAUSE) {
state = prev_state;
} else {
prev_state = state;
state = STATE_PAUSE;
}
break;
case 2: // RED manual
if (state == STATE_PAUSE) red_manual = !red_manual;
break;
case 3: // YELLOW manual
if (state == STATE_PAUSE) yellow_manual = !yellow_manual;
break;
case 4: // GREEN manual
if (state == STATE_PAUSE) green_manual = !green_manual;
break;
case 5: // BLINK_YELLOW
if (state != STATE_BLINK_YELLOW) {
prev_state = state;
state = STATE_BLINK_YELLOW;
} else {
state = prev_state;
}
 break;
}
}

// FSM-logiikka tilan perusteella
 switch (state) {
 case STATE_RED:
 gpio_pin_set_dt(&red, 1);
 gpio_pin_set_dt(&green, 0);
 gpio_pin_set_dt(&blue, 0);
 printk("RED\n");
 k_sleep(K_SECONDS(1));
 if (state == STATE_RED) state = STATE_YELLOW;
 break;

 case STATE_YELLOW:
 gpio_pin_set_dt(&red, 1);
 gpio_pin_set_dt(&green, 1);
 gpio_pin_set_dt(&blue, 0);
 printk("YELLOW\n");
 k_sleep(K_SECONDS(1));
 if (state == STATE_YELLOW) state = STATE_GREEN;
 break;

 case STATE_GREEN:
 gpio_pin_set_dt(&red, 0);
 gpio_pin_set_dt(&green, 1);
 gpio_pin_set_dt(&blue, 0);
 printk("GREEN\n");
 k_sleep(K_SECONDS(1));
 if (state == STATE_GREEN) state = STATE_RED;
 break;

case STATE_PAUSE:
 gpio_pin_set_dt(&red, 0);
 gpio_pin_set_dt(&green, 0);
 gpio_pin_set_dt(&blue, 0);
 if (red_manual) gpio_pin_set_dt(&red, 1);
 if (yellow_manual) {
 gpio_pin_set_dt(&red, 1);
 gpio_pin_set_dt(&green, 1);
}
 if (green_manual) gpio_pin_set_dt(&green, 1);
 k_sleep(K_MSEC(100)); // Lyhyt viive
break;

case STATE_BLINK_YELLOW:
 gpio_pin_set_dt(&red, 1);
 gpio_pin_set_dt(&green, 1);
 gpio_pin_set_dt(&blue, 0);
 k_sleep(K_MSEC(500));

// Tarkista tilan muutos myös kesken vilkutuksen
if (state != STATE_BLINK_YELLOW) break;
 
gpio_pin_set_dt(&red, 0);
gpio_pin_set_dt(&green, 0);
gpio_pin_set_dt(&blue, 0);
k_sleep(K_MSEC(500));
break;
  }
 }
}

// Yhteinen takaisinkutsufunktio
void button_pressed_callback(const struct device *dev, struct gpio_callback *cb, uint32_t pins) {
    struct button_msg msg;
    if (pins & BIT(button1.pin)) msg.button_id = 1;
    else if (pins & BIT(button2.pin)) msg.button_id = 2;
    else if (pins & BIT(button3.pin)) msg.button_id = 3;
    else if (pins & BIT(button4.pin)) msg.button_id = 4;
    else if (pins & BIT(button5.pin)) msg.button_id = 5;
    
    // Lähetä viesti viestijonoon
    k_msgq_put(&button_msgq, &msg, K_NO_WAIT);
}
