// Sekvenssissä voi olla myös aika mukana, joka kertoo kauanko valoa pidetään päällä. Tällöin sekvenssi muuttuu muotoon R,1000\r,Y,500\rG,1000\r jossa on valo ja aika pilkulla ja rivinvaihdolla eroteltuna. 
// 1) Nyt pitää ensin vastaanottaa sarjaportista merkkijono. Katso koodiesimerkki alta tehtävän tiedostosta dispatcher_example.c, taskifunktiosta uart_task(), jossa vastaanotetaan valosekvenssi. 
// 2) Sitten merkkijono pitää laittaa FIFO-puskuriin dispatcherille. Tämä on myös kuvattu esimerkkikoodissa. 
// 3) Dispatcher-taskin yksi toteutus on kuvattu tehtävän esimerkkikoodissa. Taskissa puretaan datat saadusta merkkijonosta. 
// 4) Dispatcher-taskista kuitenkin puuttuu FIFO-puskurit eri värien datan välitykseen, jotka pitää toteuttaa itse. 

// Perustelu: Lisätty ajan valinta
// prj.conf lisätty tämä rivi: CONFIG_HEAP_MEM_POOL_SIZE=1024

#include <zephyr/kernel.h>
#include <zephyr/sys/printk.h>
#include <zephyr/device.h>
#include <zephyr/drivers/gpio.h>
#include <zephyr/drivers/uart.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

// ---------------- LED pin configurations ----------------
static const struct gpio_dt_spec red   = GPIO_DT_SPEC_GET(DT_ALIAS(led0), gpios);
static const struct gpio_dt_spec green = GPIO_DT_SPEC_GET(DT_ALIAS(led1), gpios);
static const struct gpio_dt_spec blue  = GPIO_DT_SPEC_GET(DT_ALIAS(led2), gpios); // ei käytetä

// ---------------- UART device ----------------
#define UART_DEVICE_NODE DT_CHOSEN(zephyr_shell_uart)
static const struct device *const uart_dev = DEVICE_DT_GET(UART_DEVICE_NODE);

// ---------------- Release semaphore ----------------
K_SEM_DEFINE(release_sem, 0, 1);

// ---------------- Dispatcher FIFO ----------------
struct dispatcher_data {
    void *fifo_reserved; // Required by Zephyr FIFO
    char msg[80];        // Full line of sequences
};
K_FIFO_DEFINE(dispatcher_fifo);

// ---------------- Light FIFOs ----------------
struct light_data {
    void *fifo_reserved;
    int time_ms;
};
K_FIFO_DEFINE(red_fifo);
K_FIFO_DEFINE(yellow_fifo);
K_FIFO_DEFINE(green_fifo);

// ---------------- Hardware initialization ----------------
int init_hardware(void)
{
    const struct gpio_dt_spec leds[] = {red, green, blue};
    int ret;

    for (int i = 0; i < 3; i++) {
        if (!device_is_ready(leds[i].port)) {
            printk("LED device not ready\n");
            return -1;
        }
        ret = gpio_pin_configure_dt(&leds[i], GPIO_OUTPUT_INACTIVE);
        if (ret < 0) return ret;
    }

    if (!device_is_ready(uart_dev)) {
        printk("UART device not ready\n");
        return -1;
    }

    printk("Hardware initialized OK\n");
    return 0;
}

// ---------------- UART task ----------------
void uart_task(void *, void *, void *)
{
    char rc;
    char uart_msg[80];
    int uart_msg_cnt = 0;

    while (1) {
        if (uart_poll_in(uart_dev, (uint8_t *)&rc) == 0) {
            if (rc != '\r') {
                if (uart_msg_cnt < sizeof(uart_msg)-1) {
                    uart_msg[uart_msg_cnt++] = rc;
                }
            } else {
                uart_msg[uart_msg_cnt] = '\0';

                struct dispatcher_data *buf = k_malloc(sizeof(struct dispatcher_data));
                if (buf != NULL) {
                    strncpy(buf->msg, uart_msg, sizeof(buf->msg)-1);
                    buf->msg[sizeof(buf->msg)-1] = '\0';
                    k_fifo_put(&dispatcher_fifo, buf);
                    printk("UART msg: %s\n", uart_msg);
                } else {
                    printk("Error: malloc failed\n");
                }

                uart_msg_cnt = 0;
            }
        }
        k_msleep(10);
    }
}

// ---------------- Dispatcher task ----------------
void dispatcher_task(void *, void *, void *)
{
    while (1) {
        struct dispatcher_data *rec_item = k_fifo_get(&dispatcher_fifo, K_FOREVER);
        if (!rec_item) continue;

        char *p = rec_item->msg;
        while (*p) {
            char color;
            int time_ms;
            int chars_read;

            if (sscanf(p, " %c , %d %n", &color, &time_ms, &chars_read) == 2) {
                struct light_data *ldata = k_malloc(sizeof(struct light_data));
                if (!ldata) {
                    printk("Error: malloc failed for light_data\n");
                    break;
                }
                ldata->time_ms = time_ms;

                switch (color) {
                    case 'R': k_fifo_put(&red_fifo, ldata); break;
                    case 'Y': k_fifo_put(&yellow_fifo, ldata); break;
                    case 'G': k_fifo_put(&green_fifo, ldata); break;
                    default:
                        printk("Unknown color: %c\n", color);
                        k_free(ldata);
                        break;
                }

                k_sem_take(&release_sem, K_FOREVER); // odota, kunnes valo-task suorittaa
                p += chars_read;
            } else {
                char *next = strchr(p, ',');
                if (!next) break;
                p = next + 1;
            }

            while (*p == ',' || *p == ' ') p++;
        }

        k_free(rec_item);
    }
}

// ---------------- Light tasks ----------------
void red_task(void *, void *, void *)
{
    while (1) {
        struct light_data *ldata = k_fifo_get(&red_fifo, K_FOREVER);
        if (!ldata) continue;

        gpio_pin_set_dt(&red, 1);
        k_msleep(ldata->time_ms);
        gpio_pin_set_dt(&red, 0);

        printk("RED done (%d ms)\n", ldata->time_ms);
        k_free(ldata);

        k_sem_give(&release_sem);
    }
}

void yellow_task(void *, void *, void *)
{
    while (1) {
        struct light_data *ldata = k_fifo_get(&yellow_fifo, K_FOREVER);
        if (!ldata) continue;

        gpio_pin_set_dt(&red, 1);
        gpio_pin_set_dt(&green, 1);
        k_msleep(ldata->time_ms);
        gpio_pin_set_dt(&red, 0);
        gpio_pin_set_dt(&green, 0);

        printk("YELLOW done (%d ms)\n", ldata->time_ms);
        k_free(ldata);

        k_sem_give(&release_sem);
    }
}

void green_task(void *, void *, void *)
{
    while (1) {
        struct light_data *ldata = k_fifo_get(&green_fifo, K_FOREVER);
        if (!ldata) continue;

        gpio_pin_set_dt(&green, 1);
        k_msleep(ldata->time_ms);
        gpio_pin_set_dt(&green, 0);

        printk("GREEN done (%d ms)\n", ldata->time_ms);
        k_free(ldata);

        k_sem_give(&release_sem);
    }
}

// ---------------- Threads ----------------
#define STACKSIZE 700
#define PRIORITY 5

K_THREAD_DEFINE(dispatcher_tid, STACKSIZE, dispatcher_task, NULL, NULL, NULL, PRIORITY, 0, 0);
K_THREAD_DEFINE(uart_tid, STACKSIZE, uart_task, NULL, NULL, NULL, PRIORITY, 0, 0);
K_THREAD_DEFINE(red_tid, STACKSIZE, red_task, NULL, NULL, NULL, PRIORITY, 0, 0);
K_THREAD_DEFINE(yellow_tid, STACKSIZE, yellow_task, NULL, NULL, NULL, PRIORITY, 0, 0);
K_THREAD_DEFINE(green_tid, STACKSIZE, green_task, NULL, NULL, NULL, PRIORITY, 0, 0);

// ---------------- Main ----------------
int main(void)
{
    if (init_hardware() < 0) {
        printk("Hardware init failed\n");
        return -1;
    }

    printk("System ready. Send sequences like R,1000,Y,500,G,1000\\r via UART.\n");
    printk("Invalid entries will be skipped, sequence continues.\n");
    return 0;
}
