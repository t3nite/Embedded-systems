// Lisää sekvenssiin kirjain T, joka merkitsee sitä että sekvenssi toistetaan sen alusta alkaen n kertaa. Eli sekvenssi voi olla nyt muotoa R,100\r,Y,100\rT,5\r.
// Toistoa vasten joudut todennäköisesti tallentamaan vastaanotetun sekvenssin ohjelmaan. 

Perustelu: Lisätty mahdollisuus toistaa sekvenssi.

#include <zephyr/kernel.h>
#include <zephyr/sys/printk.h>
#include <zephyr/device.h>
#include <zephyr/drivers/gpio.h>
#include <zephyr/drivers/uart.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

// ---------------- LED pin configurations ----------------
static const struct gpio_dt_spec red   = GPIO_DT_SPEC_GET(DT_ALIAS(led0), gpios);
static const struct gpio_dt_spec green = GPIO_DT_SPEC_GET(DT_ALIAS(led1), gpios);
static const struct gpio_dt_spec blue  = GPIO_DT_SPEC_GET(DT_ALIAS(led2), gpios); // ei käytetä

// ---------------- UART device ----------------
#define UART_DEVICE_NODE DT_CHOSEN(zephyr_shell_uart)
static const struct device *const uart_dev = DEVICE_DT_GET(UART_DEVICE_NODE);

// ---------------- Release semaphore ----------------
K_SEM_DEFINE(release_sem, 0, 1);

// ---------------- Dispatcher FIFO ----------------
struct dispatcher_data {
    void *fifo_reserved;
    char msg[80];
};
K_FIFO_DEFINE(dispatcher_fifo);

// ---------------- Light FIFOs ----------------
struct light_data {
    void *fifo_reserved;
    int time_ms;
};
K_FIFO_DEFINE(red_fifo);
K_FIFO_DEFINE(yellow_fifo);
K_FIFO_DEFINE(green_fifo);

// ---------------- Hardware initialization ----------------
int init_hardware(void)
{
    const struct gpio_dt_spec leds[] = {red, green, blue};
    int ret;

    for (int i = 0; i < 3; i++) {
        if (!device_is_ready(leds[i].port)) {
            printk("LED device not ready\n");
            return -1;
        }
        ret = gpio_pin_configure_dt(&leds[i], GPIO_OUTPUT_INACTIVE);
        if (ret < 0) return ret;
    }

    if (!device_is_ready(uart_dev)) {
        printk("UART device not ready\n");
        return -1;
    }

    printk("Hardware initialized OK\n");
    return 0;
}

// ---------------- UART task ----------------
void uart_task(void *, void *, void *)
{
    char rc;
    char uart_msg[80];
    int uart_msg_cnt = 0;

    while (1) {
        if (uart_poll_in(uart_dev, (uint8_t *)&rc) == 0) {
            if (rc != '\r') {
                if (uart_msg_cnt < sizeof(uart_msg)-1) {
                    uart_msg[uart_msg_cnt++] = rc;
                }
            } else {
                uart_msg[uart_msg_cnt] = '\0';

                struct dispatcher_data *buf = k_malloc(sizeof(struct dispatcher_data));
                if (buf != NULL) {
                    strncpy(buf->msg, uart_msg, sizeof(buf->msg)-1);
                    buf->msg[sizeof(buf->msg)-1] = '\0';
                    k_fifo_put(&dispatcher_fifo, buf);
                    printk("UART msg: %s\n", uart_msg);
                } else {
                    printk("Error: malloc failed\n");
                }

                uart_msg_cnt = 0;
            }
        }
        k_msleep(10);
    }
}

// ---------------- Dispatcher task ----------------
void dispatcher_task(void *, void *, void *)
{
    while (1) {
        struct dispatcher_data *rec_item = k_fifo_get(&dispatcher_fifo, K_FOREVER);
        if (!rec_item) continue;

        char sequence_copy[80];
        strncpy(sequence_copy, rec_item->msg, sizeof(sequence_copy)-1);
        sequence_copy[sizeof(sequence_copy)-1] = '\0';

        // Etsi toistomäärä T,n (vain ensimmäinen T-komento vaikuttaa)
        int repeat_count = 1;
        char *p = sequence_copy;
        char color;
        int time_ms;
        int chars_read;
        while (*p) {
            if (sscanf(p, " %c , %d %n", &color, &time_ms, &chars_read) == 2) {
                if (color == 'T') {
                    repeat_count = time_ms;
                    break;
                }
                p += chars_read;
            } else {
                char *next = strchr(p, ',');
                if (!next) break;
                p = next + 1;
            }
            while (*p == ',' || *p == ' ') p++;
        }

        // Suorita toistot
        for (int r = 0; r < repeat_count; r++) {
            char *seq_ptr = sequence_copy;
            while (*seq_ptr) {
                if (sscanf(seq_ptr, " %c , %d %n", &color, &time_ms, &chars_read) == 2) {
                    if (color == 'T') { // ohita T
                        seq_ptr += chars_read;
                        continue;
                    }

                    struct light_data *ldata = k_malloc(sizeof(struct light_data));
                    if (!ldata) break;
                    ldata->time_ms = time_ms;

                    switch (color) {
                        case 'R': k_fifo_put(&red_fifo, ldata); break;
                        case 'Y': k_fifo_put(&yellow_fifo, ldata); break;
                        case 'G': k_fifo_put(&green_fifo, ldata); break;
                        default: k_free(ldata); break;
                    }

                    k_sem_take(&release_sem, K_FOREVER);
                    seq_ptr += chars_read;
                } else {
                    char *next = strchr(seq_ptr, ',');
                    if (!next) break;
                    seq_ptr = next + 1;
                }
                while (*seq_ptr == ',' || *seq_ptr == ' ') seq_ptr++;
            }
        }

        k_free(rec_item);
    }
}

// ---------------- Light tasks ----------------
void red_task(void *, void *, void *)
{
    while (1) {
        struct light_data *ldata = k_fifo_get(&red_fifo, K_FOREVER);
        if (!ldata) continue;

        gpio_pin_set_dt(&red, 1);
        k_msleep(ldata->time_ms);
        gpio_pin_set_dt(&red, 0);

        printk("RED done (%d ms)\n", ldata->time_ms);
        k_free(ldata);

        k_sem_give(&release_sem);
    }
}

void yellow_task(void *, void *, void *)
{
    while (1) {
        struct light_data *ldata = k_fifo_get(&yellow_fifo, K_FOREVER);
        if (!ldata) continue;

        gpio_pin_set_dt(&red, 1);
        gpio_pin_set_dt(&green, 1);
        k_msleep(ldata->time_ms);
        gpio_pin_set_dt(&red, 0);
        gpio_pin_set_dt(&green, 0);

        printk("YELLOW done (%d ms)\n", ldata->time_ms);
        k_free(ldata);

        k_sem_give(&release_sem);
    }
}

void green_task(void *, void *, void *)
{
    while (1) {
        struct light_data *ldata = k_fifo_get(&green_fifo, K_FOREVER);
        if (!ldata) continue;

        gpio_pin_set_dt(&green, 1);
        k_msleep(ldata->time_ms);
        gpio_pin_set_dt(&green, 0);

        printk("GREEN done (%d ms)\n", ldata->time_ms);
        k_free(ldata);

        k_sem_give(&release_sem);
    }
}

// ---------------- Threads ----------------
#define STACKSIZE 700
#define PRIORITY 5

K_THREAD_DEFINE(dispatcher_tid, STACKSIZE, dispatcher_task, NULL, NULL, NULL, PRIORITY, 0, 0);
K_THREAD_DEFINE(uart_tid, STACKSIZE, uart_task, NULL, NULL, NULL, PRIORITY, 0, 0);
K_THREAD_DEFINE(red_tid, STACKSIZE, red_task, NULL, NULL, NULL, PRIORITY, 0, 0);
K_THREAD_DEFINE(yellow_tid, STACKSIZE, yellow_task, NULL, NULL, NULL, PRIORITY, 0, 0);
K_THREAD_DEFINE(green_tid, STACKSIZE, green_task, NULL, NULL, NULL, PRIORITY, 0, 0);

// ---------------- Main ----------------
int main(void)
{
    if (init_hardware() < 0) {
        printk("Hardware init failed\n");
        return -1;
    }

    printk("System ready. Send sequences like R,100,Y,100,T,5\\r via UART.\n");
    printk("Invalid entries will be skipped, sequence continues.\n");
    return 0;
}
