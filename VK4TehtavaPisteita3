/* +1p suoritus: Debugin asetus päälle / pois

Lisää toiminnallisuus missä sarjaportin kautta voidaan laittaa debuggitulostukset päälle ja pois. 

Tämä voidaan tehdä samoin kuin valosekvenssin lukeminen sarjaportista, mutta varataan sitä varten komentokirjain 'D'. 

Tässä täytyy muokata esimerkkikoodia siten, että DEBUG-vakion sijasta käytetäänkin uutta muuttujaa lippuna onko debug päällä vai ei. */

// Perustelu: Lisätty asetus D-kirjaimeen.

#include <zephyr/kernel.h>
#include <zephyr/sys/printk.h>
#include <zephyr/device.h>
#include <zephyr/drivers/gpio.h>
#include <zephyr/timing/timing.h>
#include <string.h>
#include <zephyr/sys/atomic.h>    
#include <zephyr/drivers/uart.h>  

// *** CONFIG NOTES ***
// Lisää prj.conf -tiedostoon:
// CONFIG_TIMING_FUNCTIONS=y
// CONFIG_PRINTK=y
// CONFIG_STDOUT_CONSOLE=y
// CONFIG_HEAP_MEM_POOL_SIZE=2048
// CONFIG_SERIAL=y                     
// CONFIG_UART_INTERRUPT_DRIVEN=y      
// *********************

// I/O pin configurations (nrf5340_audio: led0 = red, led1 = green)
static const struct gpio_dt_spec red   = GPIO_DT_SPEC_GET(DT_ALIAS(led0), gpios);
static const struct gpio_dt_spec green = GPIO_DT_SPEC_GET(DT_ALIAS(led1), gpios);

// Thread asetukset
#define STACKSIZE 1024 // Nostettu hieman UART-käsittelyä varten
#define PRIORITY 5
#define DEBUG_PRIORITY 7   // debug-taski saa pienemmän prioriteetin

// --- LISÄTTY: Globaali lippu debug-tulostusten hallintaan
// atominen muuttuja on turvallinen säikeiden välillä
static atomic_t debug_enabled;

// Debug FIFO
K_FIFO_DEFINE(debug_fifo);

// Viestirakenne FIFOon
struct debug_msg {
    void *fifo_reserved;  // varattu fifo-linkitykseen
    char data[128];
};

// --- MUOKATTU: Funktio viestin lisäämiseen FIFOon
static void debug_log(const char *fmt, ...)
{
    // Tarkistetaan ensin, onko debuggaus päällä
    if (!atomic_get(&debug_enabled)) {
        return; // Jos ei, poistutaan funktiosta heti
    }

    struct debug_msg *msg = k_malloc(sizeof(struct debug_msg));
    if (!msg) return; // ei muistia

    va_list args;
    va_start(args, fmt);
    vsnprintk(msg->data, sizeof(msg->data), fmt, args);
    va_end(args);

    k_fifo_put(&debug_fifo, msg);
}

// Debug-task
void debug_task(void *, void *, void *)
{
    while (1) {
        struct debug_msg *msg = k_fifo_get(&debug_fifo, K_FOREVER);
        if (msg) {
            printk("%s", msg->data);
            k_free(msg);
        }
    }
}
K_THREAD_DEFINE(debug_thread, STACKSIZE, debug_task, NULL, NULL, NULL,
                DEBUG_PRIORITY, 0, 0);

// Sekvenssitaskeja
void sequence_task(void *, void *, void*);
K_THREAD_DEFINE(seq_thread, STACKSIZE, sequence_task, NULL, NULL, NULL,
                PRIORITY, 0, 0);
                
// --- LISÄTTY: Sarjaportin käsittely ---

// Haetaan konsolin UART-laite device treestä
static const struct device *uart_dev = DEVICE_DT_GET(DT_CHOSEN(zephyr_console));

// Message queue sarjaportilta tuleville merkeille
K_MSGQ_DEFINE(uart_msgq, sizeof(char), 16, 4);

// UART-keskeytyksen käsittelijä (callback)
static void uart_cb(const struct device *dev, void *user_data)
{
    uint8_t c;
    if (!uart_irq_update(dev) || !uart_irq_rx_ready(dev)) {
        return;
    }
    while (uart_fifo_read(dev, &c, 1) == 1) {
        // Laitetaan merkki jonoon, ei odoteta jos jono on täynnä
        k_msgq_put(&uart_msgq, &c, K_NO_WAIT);
    }
}

// Säie, joka käsittelee sarjaportilta tulleet komennot
void uart_input_thread(void *, void *, void *)
{
    char rx_char;
    while (1) {
        // Odota, kunnes jonoon tulee merkki
        if (k_msgq_get(&uart_msgq, &rx_char, K_FOREVER) == 0) {
            if (rx_char == 'D' || rx_char == 'd') {
                // Vaihda debug-lipun tilaa (0->1 tai 1->0)
                atomic_xor(&debug_enabled, 1);
                
                // Tulostetaan aina tieto komennon onnistumisesta
                printk("--> Debug-tulostus nyt: %s\n", atomic_get(&debug_enabled) ? "PÄÄLLÄ" : "POIS");
            }
        }
    }
}
K_THREAD_DEFINE(uart_thread, STACKSIZE, uart_input_thread, NULL, NULL, NULL,
                PRIORITY, 0, 0);
// ------------------------------------------

// LED init helper
static void init_led(const struct gpio_dt_spec *led) {
    int ret = gpio_pin_configure_dt(led, GPIO_OUTPUT_ACTIVE);
    if (ret < 0) {
        return;
    }
    gpio_pin_set_dt(led, 0);
}

int main(void)
{
    timing_init();
    
    // --- LISÄTTY: Asetetaan debug-lippu päälle ohjelman alussa
    atomic_set(&debug_enabled, 1);

    init_led(&red);
    init_led(&green);
    
    // --- LISÄTTY: UART-alustus
    if (!device_is_ready(uart_dev)) {
        printk("UART device not found!");
        return 0;
    }
    // Asetetaan keskeytyspohjainen callback UARTille
    uart_irq_callback_user_data_set(uart_dev, uart_cb, NULL);
    uart_irq_rx_enable(uart_dev);
    // -------------------------------------

    k_msleep(100);

    printk("Ohjelma kaynnistetty. Laheta 'D' vaihtaaksesi debug-tulostuksen tilaa.\n");
    debug_log("Program started..\n");

    // Huom: main-funktio päättyy Zephyrissä, mutta säikeet jäävät ajoon.
    // timing_start() on siirretty sekvenssisäikeeseen, jotta se mittaa vain sitä.
    return 0;
}

// Task implementing R → Y (=R+G) → G
void sequence_task(void *, void *, void*) {
    while (true) {
        uint64_t seq_total_ns = 0;

        // --- RED ---
        timing_start();
        timing_t r_start = timing_counter_get();

        gpio_pin_set_dt(&red, 1);
        debug_log("Red on\n");
        k_sleep(K_SECONDS(1));
        gpio_pin_set_dt(&red, 0);
        debug_log("Red off\n");
        k_sleep(K_SECONDS(1));

        timing_t r_end = timing_counter_get();
        timing_stop();
        uint64_t r_ns = timing_cycles_to_ns(timing_cycles_get(&r_start, &r_end));
        debug_log("Red task: %lld us\n", r_ns/1000);
        seq_total_ns += r_ns;

        // --- YELLOW = RED+GREEN ---
        timing_start();
        timing_t y_start = timing_counter_get();

        gpio_pin_set_dt(&red, 1);
        gpio_pin_set_dt(&green, 1);
        debug_log("Yellow on (R+G)\n");
        k_sleep(K_SECONDS(1));
        gpio_pin_set_dt(&red, 0);
        gpio_pin_set_dt(&green, 0);
        debug_log("Yellow off\n");
        k_sleep(K_SECONDS(1));

        timing_t y_end = timing_counter_get();
        timing_stop();
        uint64_t y_ns = timing_cycles_to_ns(timing_cycles_get(&y_start, &y_end));
        debug_log("Yellow task: %lld us\n", y_ns/1000);
        seq_total_ns += y_ns;

        // --- GREEN ---
        timing_start();
        timing_t g_start = timing_counter_get();

        gpio_pin_set_dt(&green, 1);
        debug_log("Green on\n");
        k_sleep(K_SECONDS(1));
        gpio_pin_set_dt(&green, 0);
        debug_log("Green off\n");
        k_sleep(K_SECONDS(1));

        timing_t g_end = timing_counter_get();
        timing_stop();
        uint64_t g_ns = timing_cycles_to_ns(timing_cycles_get(&g_start, &g_end));
        debug_log("Green task: %lld us\n", g_ns/1000);
        seq_total_ns += g_ns;

        // --- Kokonaiskesto ---
        debug_log("RYG sequence total: %lld us\n", seq_total_ns/1000);

        // pieni tauko seuraavaan kierrokseen
        k_msleep(500);
    }
}
