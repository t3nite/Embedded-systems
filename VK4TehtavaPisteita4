/* +1p suoritus: Koodiin toiminnallisuuden tarkistuksia

Lisää ohjelmaasi assert-tarkistuksia, joilla nähdään että miten ohjelmasi pitäisi toimia.

On vaikea antaa täsmällistä ohjetta kun ohjelmat ovat erilaisia, mutta mieti ohjelmastasi missä kohti olisi järkevää olla assert-tarkistuksia. Lisää vähintään 3-4 asserttia ohjelmaasi.  

Esimerkkinä yksi assertin paikka voisi olla että jos sarjaportista luetaan vääriä / ylimääräisiä merkkejä, niin nämä ilmaistaan assertin avulla. */

// Perustelu: Lisätty 4 kpl assert-tarkistuksia.

#include <zephyr/kernel.h>
#include <zephyr/sys/printk.h>
#include <zephyr/device.h>
#include <zephyr/drivers/gpio.h>
#include <zephyr/timing/timing.h>
#include <string.h>
#include <zephyr/sys/atomic.h>
#include <zephyr/drivers/uart.h>
#include <stdarg.h>
#include <stdlib.h>

// *** CONFIG NOTES ***
// Lisää prj.conf -tiedostoon:
// CONFIG_TIMING_FUNCTIONS=y
// CONFIG_PRINTK=y
// CONFIG_STDOUT_CONSOLE=y
// CONFIG_HEAP_MEM_POOL_SIZE=2048
// CONFIG_SERIAL=y
// CONFIG_UART_INTERRUPT_DRIVEN=y
// CONFIG_ASSERT=y
// *********************

static const struct gpio_dt_spec red   = GPIO_DT_SPEC_GET(DT_ALIAS(led0), gpios);
static const struct gpio_dt_spec green = GPIO_DT_SPEC_GET(DT_ALIAS(led1), gpios);

#define STACKSIZE 1024
#define PRIORITY 5
#define DEBUG_PRIORITY 7

static atomic_t debug_enabled;

K_FIFO_DEFINE(debug_fifo);

struct debug_msg {
    void *fifo_reserved;
    char data[128];
};

static void debug_log(const char *fmt, ...)
{
    if (!atomic_get(&debug_enabled)) {
        return;
    }

    struct debug_msg *msg = k_malloc(sizeof(struct debug_msg));
    __ASSERT(msg != NULL, "Failed to allocate memory for debug message"); // 1. assert

    va_list args;
    va_start(args, fmt);
    vsnprintk(msg->data, sizeof(msg->data), fmt, args);
    va_end(args);

    k_fifo_put(&debug_fifo, msg);
}

void debug_task(void *, void *, void *)
{
    while (1) {
        struct debug_msg *msg = k_fifo_get(&debug_fifo, K_FOREVER);
        if (msg) {
            printk("%s", msg->data);
            k_free(msg);
        }
    }
}
K_THREAD_DEFINE(debug_thread, STACKSIZE, debug_task, NULL, NULL, NULL,
                DEBUG_PRIORITY, 0, 0);

void sequence_task(void *, void *, void*);
K_THREAD_DEFINE(seq_thread, STACKSIZE, sequence_task, NULL, NULL, NULL,
                PRIORITY, 0, 0);

static const struct device *uart_dev = DEVICE_DT_GET(DT_CHOSEN(zephyr_console));
K_MSGQ_DEFINE(uart_msgq, sizeof(char), 16, 4);

static void uart_cb(const struct device *dev, void *user_data)
{
    uint8_t c;
    if (!uart_irq_update(dev) || !uart_irq_rx_ready(dev)) {
        return;
    }
    while (uart_fifo_read(dev, &c, 1) == 1) {
        int err = k_msgq_put(&uart_msgq, &c, K_NO_WAIT);
        __ASSERT(err == 0, "Failed to put char in MSGQ"); // 4. assert
    }
}

void uart_input_thread(void *, void *, void *)
{
    char rx_char;
    while (1) {
        if (k_msgq_get(&uart_msgq, &rx_char, K_FOREVER) == 0) {
            if (rx_char == 'D' || rx_char == 'd') {
                atomic_xor(&debug_enabled, 1);
                printk("--> Debug-tulostus nyt: %s\n", atomic_get(&debug_enabled) ? "PÄÄLLÄ" : "POIS");
            }
        }
    }
}
K_THREAD_DEFINE(uart_thread, STACKSIZE, uart_input_thread, NULL, NULL, NULL,
                PRIORITY, 0, 0);

static void init_led(const struct gpio_dt_spec *led) {
    int ret = gpio_pin_configure_dt(led, GPIO_OUTPUT_ACTIVE);
    __ASSERT(ret >= 0, "Failed to configure LED pin"); // 2. assert
    gpio_pin_set_dt(led, 0);
}

int main(void)
{
    timing_init();

    atomic_set(&debug_enabled, 1);

    init_led(&red);
    init_led(&green);

    __ASSERT(device_is_ready(uart_dev), "UART device not ready"); // 3. assert
    uart_irq_callback_user_data_set(uart_dev, uart_cb, NULL);
    uart_irq_rx_enable(uart_dev);

    k_msleep(100);

    printk("Ohjelma kaynnistetty. Laheta 'D' vaihtaaksesi debug-tulostuksen tilaa.\n");
    debug_log("Program started..\n");

    return 0;
}

void sequence_task(void *, void *, void*) {
    while (true) {
        uint64_t seq_total_ns = 0;

        // RED
        timing_start();
        timing_t r_start = timing_counter_get();
        gpio_pin_set_dt(&red, 1);
        debug_log("Red on\n");
        k_sleep(K_SECONDS(1));
        gpio_pin_set_dt(&red, 0);
        debug_log("Red off\n");
        k_sleep(K_SECONDS(1));
        timing_t r_end = timing_counter_get();
        timing_stop();
        uint64_t r_ns = timing_cycles_to_ns(timing_cycles_get(&r_start, &r_end));
        debug_log("Red task: %lld us\n", r_ns/1000);
        seq_total_ns += r_ns;

        // YELLOW
        timing_start();
        timing_t y_start = timing_counter_get();
        gpio_pin_set_dt(&red, 1);
        gpio_pin_set_dt(&green, 1);
        debug_log("Yellow on (R+G)\n");
        k_sleep(K_SECONDS(1));
        gpio_pin_set_dt(&red, 0);
        gpio_pin_set_dt(&green, 0);
        debug_log("Yellow off\n");
        k_sleep(K_SECONDS(1));
        timing_t y_end = timing_counter_get();
        timing_stop();
        uint64_t y_ns = timing_cycles_to_ns(timing_cycles_get(&y_start, &y_end));
        debug_log("Yellow task: %lld us\n", y_ns/1000);
        seq_total_ns += y_ns;

        // GREEN
        timing_start();
        timing_t g_start = timing_counter_get();
        gpio_pin_set_dt(&green, 1);
        debug_log("Green on\n");
        k_sleep(K_SECONDS(1));
        gpio_pin_set_dt(&green, 0);
        debug_log("Green off\n");
        k_sleep(K_SECONDS(1));
        timing_t g_end = timing_counter_get();
        timing_stop();
        uint64_t g_ns = timing_cycles_to_ns(timing_cycles_get(&g_start, &g_end));
        debug_log("Green task: %lld us\n", g_ns/1000);
        seq_total_ns += g_ns;

        debug_log("RYG sequence total: %lld us\n", seq_total_ns/1000);

        k_msleep(500);
    }
}
