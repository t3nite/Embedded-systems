// CONFIG_HEAP_MEM_POOL_SIZE=1024 prj.conf
// cd C:\5_Test_automation>robot robotti3.robot

#include <ctype.h>
#include <zephyr/kernel.h>
#include <zephyr/sys/printk.h>
#include <zephyr/device.h>
#include <zephyr/drivers/gpio.h>
#include <zephyr/drivers/uart.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

// ---------------- VIRHEKOODIT ----------------
#define TIME_LEN_ERROR      -1
#define TIME_ARRAY_ERROR    -2
#define TIME_VALUE_ERROR    -3
#define TIME_ZERO_ERROR     -4

#define TRAFFIC_OK            0
#define TRAFFIC_CHAR_ERROR   -5
#define TRAFFIC_FORMAT_ERROR -6
#define TRAFFIC_REPEAT_ERROR -7

// ---------------- RAKENTEET ----------------
typedef struct {
    char colors[40];
    int times[40];
    int length;
    int repeat;
} traffic_sequence_t;

int time_parse(char *time);
int traffic_parse(const char *input, traffic_sequence_t *seq);
void uart_print(const char *msg);

// ---------------- LED PINIT ----------------
static const struct gpio_dt_spec red   = GPIO_DT_SPEC_GET(DT_ALIAS(led0), gpios);
static const struct gpio_dt_spec green = GPIO_DT_SPEC_GET(DT_ALIAS(led1), gpios);
static const struct gpio_dt_spec blue  = GPIO_DT_SPEC_GET(DT_ALIAS(led2), gpios);

// ---------------- UART-LAITE ----------------
#define UART_DEVICE_NODE DT_CHOSEN(zephyr_shell_uart)
static const struct device *const uart_dev = DEVICE_DT_GET(UART_DEVICE_NODE);

// ---------------- SYNKRONISAATIO ----------------
K_SEM_DEFINE(release_sem, 0, 1);

// ---------------- FIFO-RAKENTEET ----------------
struct dispatcher_data {
    void *fifo_reserved;
    char msg[80];
};
K_FIFO_DEFINE(dispatcher_fifo);

struct light_data {
    void *fifo_reserved;
    char color;
    int time_ms;
};
K_FIFO_DEFINE(light_fifo);

// ---------------- UART-TULOSTUS ----------------
void uart_print(const char *msg) {
    if (!device_is_ready(uart_dev)) return;
    while (*msg) {
        uart_poll_out(uart_dev, *msg++);
    }
}

// ---------------- UART SEND STRING FUNKTIO ROBOTILLE ----------------
void uart_send_string(const char *msg)
{
    if (!device_is_ready(uart_dev)) return;
    size_t len = strlen(msg);
    for (size_t i = 0; i < len; i++) {
        uart_poll_out(uart_dev, msg[i]);
    }
}

// ---------------- HARDIS INITIALISOINTI ----------------
int init_hardware(void)
{
    const struct gpio_dt_spec leds[] = {red, green, blue};
    int ret;

    for (int i = 0; i < 3; i++) {
        if (!device_is_ready(leds[i].port)) {
            printk("LED device not ready\n");
            return -1;
        }
        ret = gpio_pin_configure_dt(&leds[i], GPIO_OUTPUT_INACTIVE);
        if (ret < 0) return ret;
    }

    if (!device_is_ready(uart_dev)) {
        printk("UART device not ready\n");
        return -1;
    }

    printk("Hardware initialized OK\n");
    return 0;
}

// ---------------- UART TASK ----------------
void uart_task(void *, void *, void *)
{
    char rc;
    char uart_msg[80];
    int uart_msg_cnt = 0;

    while (1) {
        if (uart_poll_in(uart_dev, (uint8_t *)&rc) == 0) {

            if (rc == 'Z') {
                if (uart_msg_cnt > 0) {
                    uart_msg[uart_msg_cnt] = '\0';
                    struct dispatcher_data *buf = k_malloc(sizeof(struct dispatcher_data));
                    if (buf != NULL) {
                        strncpy(buf->msg, uart_msg, sizeof(buf->msg)-1);
                        buf->msg[sizeof(buf->msg)-1] = '\0';
                        k_fifo_put(&dispatcher_fifo, buf);
                    }
                }
                uart_msg_cnt = 0;
                continue;
            }

            if (rc == '\r' || rc == '\n' || rc == ' ' || rc == '\t') continue;

            if (uart_msg_cnt < sizeof(uart_msg)-1) {
                uart_msg[uart_msg_cnt++] = rc;
            }
        }
        k_msleep(10);
    }
}

void dispatcher_task(void *, void *, void *)
{
    while (1) {
        struct dispatcher_data *rec_item = k_fifo_get(&dispatcher_fifo, K_FOREVER);
        if (!rec_item) continue;

        size_t msg_len = strlen(rec_item->msg);

        // Poista lopetus-Z jos se on vielä jäljellä
        if (msg_len > 0 && rec_item->msg[msg_len - 1] == 'Z') {
            rec_item->msg[msg_len - 1] = '\0';
            msg_len--;
        }

        bool all_digits = true;
        for (size_t i = 0; i < msg_len; i++) {
            if (!isdigit((unsigned char)rec_item->msg[i])) {
                all_digits = false;
                break;
            }
        }

        if (msg_len == 6 && all_digits) {
            // ----------------------
            // Aikasyöte (000000–235959)
            // ----------------------
            int seconds = time_parse(rec_item->msg);

            if (seconds > 0) {
                char outbuf[32];
                snprintf(outbuf, sizeof(outbuf), "%d\r\n", seconds);
                uart_send_string(outbuf);

                // Luodaan sinisen LEDin data
                struct light_data *ldata = k_malloc(sizeof(struct light_data));
                if (ldata) {
                    ldata->color = 'B';
                    ldata->time_ms = 1000;
                    k_fifo_put(&light_fifo, ldata);
                }
            } else {
                uart_send_string("TimeParseError\r\n");
            }

        } else if (strchr(rec_item->msg, ',') != NULL) {
            // ----------------------
            // Liikennevalosyntaksi (esim. R,100,Y,500)
            // ----------------------
            traffic_sequence_t seq;
            int res = traffic_parse(rec_item->msg, &seq);

            if (res != TRAFFIC_OK) {
                uart_send_string("TRAFFIC_FORMAT_ERROR\r\n");
            } else {
                // Tarkistetaan sekvenssi: värit R/Y/G ja ajat >0
                bool valid_sequence = (seq.repeat > 0);
                for (int i = 0; i < seq.length && valid_sequence; i++) {
                    if (seq.times[i] <= 0 ||
                        (seq.colors[i] != 'R' && seq.colors[i] != 'Y' && seq.colors[i] != 'G')) {
                        valid_sequence = false;
                    }
                }

                if (!valid_sequence) {
                    uart_send_string("TRAFFIC_FORMAT_ERROR\r\n");
                } else {
                    // Suoritetaan sekvenssi normaalisti
                    for (int r = 0; r < seq.repeat; r++) {
                        for (int i = 0; i < seq.length; i++) {
                            struct light_data *ldata = k_malloc(sizeof(struct light_data));
                            if (!ldata) continue;

                            ldata->color = seq.colors[i];
                            ldata->time_ms = seq.times[i];
                            k_fifo_put(&light_fifo, ldata);

                            k_sem_take(&release_sem, K_FOREVER);
                        }
                    }
                }
            }

        } else {
            // ----------------------
            // Kaikki muut epäkelvot syötteet aikasyötteille
            // ----------------------
            uart_send_string("TimeParseError\r\n");
        }

        k_free(rec_item);
    }
}

// ---------------- LIGHT TASK ----------------
void light_task(void *, void *, void *)
{
    while (1) {
        struct light_data *ldata = k_fifo_get(&light_fifo, K_FOREVER);
        if (!ldata) continue;

        gpio_pin_set_dt(&red, 0);
        gpio_pin_set_dt(&green, 0);
        gpio_pin_set_dt(&blue, 0);

        switch (ldata->color) {
            case 'R': gpio_pin_set_dt(&red, 1); break;
            case 'Y': gpio_pin_set_dt(&red, 1); gpio_pin_set_dt(&green, 1); break;
            case 'G': gpio_pin_set_dt(&green, 1); break;
            case 'B': gpio_pin_set_dt(&blue, 1); break;
        }

        k_msleep(ldata->time_ms);

        gpio_pin_set_dt(&red, 0);
        gpio_pin_set_dt(&green, 0);
        gpio_pin_set_dt(&blue, 0);

        k_free(ldata);
        k_sem_give(&release_sem);
    }
}

// ---------------- THREADIT ----------------
#define STACKSIZE 700
#define PRIORITY 5

K_THREAD_DEFINE(dispatcher_tid, STACKSIZE, dispatcher_task, NULL, NULL, NULL, PRIORITY, 0, 0);
K_THREAD_DEFINE(uart_tid, STACKSIZE, uart_task, NULL, NULL, NULL, PRIORITY, 0, 0);
K_THREAD_DEFINE(light_tid, STACKSIZE, light_task, NULL, NULL, NULL, PRIORITY, 0, 0);

// ---------------- MAIN ----------------
int main(void)
{
    if (init_hardware() < 0) {
        printk("Hardware init failed\n");
        return -1;
    }

    printk("System ready. Send e.g. 'R,1000,Y,1000,G,1000,T,2Z' or '000001Z' via UART.\n");
    return 0;
}

// ---------------- Parserit ----------------
int traffic_parse(const char *input, traffic_sequence_t *seq) {
    if (!input || !seq) return TRAFFIC_FORMAT_ERROR;

    seq->length = 0;
    seq->repeat = 1;

    const char *p = input;
    while (*p) {
        char color;
        int time, nread;
        if (sscanf(p, " %c , %d %n", &color, &time, &nread) >= 2) {
            if (color == 'T') {
                seq->repeat = time;
                if (seq->repeat <= 0) return TRAFFIC_REPEAT_ERROR;
            } else if (color == 'R' || color == 'Y' || color == 'G') {
                if (seq->length >= 40) return TRAFFIC_FORMAT_ERROR;
                if (time > 10000) return TRAFFIC_FORMAT_ERROR;
                seq->colors[seq->length] = color;
                seq->times[seq->length] = time;
                seq->length++;
            } else {
                return TRAFFIC_CHAR_ERROR;
            }
            p += nread;
        } else {
            return TRAFFIC_FORMAT_ERROR;
        }
        while (*p == ',' || *p == ' ' || *p == '\r' || *p == '\n') p++;
    }
    return TRAFFIC_OK;
}

int time_parse(char *time) {
    int seconds = TIME_LEN_ERROR;

    if (time == NULL) return TIME_ARRAY_ERROR;
    if (strlen(time) != 6) return TIME_LEN_ERROR;

    for (int i = 0; i < 6; ++i) {
        if (!isdigit((unsigned char)time[i])) return TIME_VALUE_ERROR;
    }

    int values[3];
    values[2] = atoi(time+4);
    time[4] = 0;
    values[1] = atoi(time+2);
    time[2] = 0;
    values[0] = atoi(time);

    if (values[0] < 0 || values[0] > 23) return TIME_VALUE_ERROR;
    if (values[1] < 0 || values[1] > 59) return TIME_VALUE_ERROR;
    if (values[2] < 0 || values[2] > 59) return TIME_VALUE_ERROR;

    if (values[1] == 0 && values[2] == 0) return TIME_ZERO_ERROR;

    seconds = values[1] * 60 + values[2];
    return seconds;
}
